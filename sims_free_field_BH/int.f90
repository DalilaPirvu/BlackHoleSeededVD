module integrator
    use constants, only : dl
    use eom

    implicit none

    integer, parameter :: order = 5, niter = 8
    real(dl), allocatable, dimension(:,:) :: g
    real(dl), parameter :: a(order,order) = reshape( (/ &
        +0.5923172126404727187856601017997934066D-1, &
        -1.9570364359076037492643214050884060018D-2, &
        +1.1254400818642955552716244215090748773D-2, &
        -0.5593793660812184876817721964475928216D-2, &
        +1.5881129678659985393652424705934162371D-3, &
        +1.2815100567004528349616684832951382219D-1, &
        +1.1965716762484161701032287870890954823D-1, &
        -2.4592114619642200389318251686004016630D-2, &
        +1.0318280670683357408953945056355839486D-2, &
        -2.7689943987696030442826307588795957613D-3, &
        +1.1377628800422460252874127381536557686D-1, &
        +2.6000465168064151859240589518757397939D-1, &
        +1.4222222222222222222222222222222222222D-1, &
        -2.0690316430958284571760137769754882933D-2, &
        +4.6871545238699412283907465445931044619D-3, &
        +1.2123243692686414680141465111883827708D-1, &
        +2.2899605457899987661169181236146325697D-1, &
        +3.0903655906408664483376269613044846112D-1, &
        +1.1965716762484161701032287870890954823D-1, &
        -0.9687563141950739739034827969555140871D-2, &
        +1.1687532956022854521776677788936526508D-1, &
        +2.4490812891049541889746347938229502468D-1, &
        +2.7319004362580148889172820022935369566D-1, &
        +2.5888469960875927151328897146870315648D-1, &
        +0.5923172126404727187856601017997934066D-1 /) , [order,order])
    real(dl), parameter :: b(order) = (/ &
        +1.1846344252809454375713202035995868132D-1, &
        +2.3931433524968323402064575741781909646D-1, &
        +2.8444444444444444444444444444444444444D-1, &
        +2.3931433524968323402064575741781909646D-1, &
        +1.1846344252809454375713202035995868132D-1 /)

contains


    subroutine gl10(y, dt, m2, lamb, frac, becmu)
        real(dl), intent(inout) :: y(1:nVar)
        real(dl), intent(in) :: dt, m2, lamb, becmu
        integer, intent(in) :: frac
        integer :: i, k

        g = 0._dl

        do k = 1,niter
            g = matmul(g,a)
            do i=1,order
                call derivs(y + g(:,i)*dt, g(:,i), m2, lamb, frac, becmu)
            enddo
        enddo

        y = y + matmul(g,b)*dt

    end subroutine gl10


    subroutine init_integrator(nv)
        integer, intent(in) :: nv

        allocate(g(nv,order))

    end subroutine init_integrator


end module integrator
